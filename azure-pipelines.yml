schedules:
- cron: 0 10 * * *
  displayName: ðŸŸ£Every day at 10:00 UTC
  branches:
    include:
    - main
  always: true

resources:
  repositories:
  - repository: 1ESPipelineTemplates
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release

variables:
- name: system.debug
  value: true
- name: azureSubscriptionForStage1Download
  value: 'SourceDotNet Stage1 Publish'
- name: webAppName
  value: 'netsourceindexprod'
- name: resourceGroupName
  value: 'source.dot.net'

# Note: the subscription name variables need to be at the pipeline level to be used in the AzureCLI tasks.
#       that's because the tasks get looked at very early in the pipeline processing.
#       Also, make sure to use the template expression syntax ${{ }}
#       Issue: https://github.com/microsoft/azure-pipelines-tasks/issues/14365#issuecomment-2286398867

- ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/main')) }}:
  - name: poolName
    value: 'NetSourceIndexProd-Pool'
  - name: azureSubscriptionForStorageAndWebAppSlot
    value: 'NetSourceIndex-Prod'
  - name: isOfficialBuild
    value: True
  - name: temporaryDeploymentSlot
    value: 'staging'
  - name: storageAccountName
    value: 'netsourceindexprod'
  - name: stagingHost
    value: 'staging.source.dot.net'
- ${{ else }}:
  - name: poolName
    value: 'NetSourceIndexValid-Pool'
  - name: azureSubscriptionForStorageAndWebAppSlot
    value: 'NetSourceIndex-Validation-Prod'
  - name: isOfficialBuild
    value: False
  - name: temporaryDeploymentSlot
    value: 'validation'
  - name: storageAccountName
    value: 'netsourceindexvalidprod'

extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1ESPipelineTemplates
  parameters:
    settings:
      networkIsolationPolicy: Permissive,CFSClean2
    pool:
      name: ${{ variables.poolName }}
      image: 1es-pt-agent-image
      os: windows
    customBuildTags:
    - ES365AIMigrationTooling
    stages:
    - stage: stage
      jobs:
      - job: BuildIndex
        displayName: Build Source Index
        timeoutInMinutes: 360

        templateContext:
          outputs:
          - output: nuget
            displayName: 'NuGet push'
            packageParentPath: '$(Build.ArtifactStagingDirectory)'
            packagesToPush: '$(Build.ArtifactStagingDirectory)/packages/*.nupkg'
            nuGetFeedType: 'internal'
            publishVstsFeed: '9ee6d478-d288-47f7-aacc-f6e6d082ae6d/d1622942-d16f-48e5-bc83-96f4539e7601'
          - output: pipelineArtifact
            condition: always()
            targetPath: $(Build.ArtifactStagingDirectory)/logs
            artifactName: logs

        steps:
        - checkout: self
          clean: true
          submodules: true

        - task: DeleteFiles@1
          displayName: ðŸŸ£Delete files from bin
          inputs:
            SourceFolder: bin
            Contents: '**/*'

        - task: UseDotNet@2
          displayName: ðŸŸ£Install .NET Sdk
          inputs:
            useGlobalJson: true

        - task: DotNetCoreCLI@2
          displayName: ðŸŸ£dotnet restore
          inputs:
            command: custom
            custom: restore
            projects: |
              **\*.sln

        - task: DotNetCoreCLI@2
          displayName: ðŸŸ£dotnet build
          inputs:
            command: 'build'
            projects: |
              src\source-indexer.sln
              src\SourceBrowser\SourceBrowser.sln
            arguments: '/p:PackageOutputPath=$(Build.ArtifactStagingDirectory)/packages /p:EnableDebugLogging=true'

        - task: AzureCLI@2
          displayName: ðŸŸ£Clone Stage1 data
          inputs:
            azureSubscription: ${{ variables.azureSubscriptionForStage1Download }}
            addSpnToEnvironment: true
            scriptType: 'ps'
            scriptLocation: 'inlineScript'
            inlineScript: |
              dotnet build build.proj /t:Clone /v:n /bl:$(Build.ArtifactStagingDirectory)/logs/clone.binlog /p:Stage1StorageAccount=netsourceindexstage1 /p:Stage1StorageContainer=stage1

        - task: DotNetCoreCLI@2
          displayName: ðŸŸ£Prepare All Repositories
          inputs:
            command: 'build'
            projects: 'build.proj'
            arguments: '/t:Prepare /v:n /bl:$(Build.ArtifactStagingDirectory)/logs/prepare.binlog'

        - task: DotNetCoreCLI@2
          displayName: ðŸŸ£Build source index
          inputs:
            command: 'build'
            projects: 'build.proj'
            arguments: '/t:BuildIndex /v:n /bl:$(Build.ArtifactStagingDirectory)/logs/build.binlog'

        - task: CopyFiles@2
          displayName: ðŸŸ£Copy webapp files
          inputs:
            sourceFolder: bin/index/
            contents: |
              **
              !index/**
            targetFolder: bin/webapp-stage/

            cleanTargetFolder: true

        - pwsh: New-Item -ItemType File -Force -Path bin/index/index/.health
          displayName: ðŸŸ£Create .health file

        - powershell: deployment/normalize-case.ps1 -Root bin/index/index/
          displayName: ðŸŸ£Normalize Case Of Index Files

        - task: AzureCLI@2
          displayName: ðŸŸ£Create new storage container
          inputs:
            azureSubscription: ${{ variables.azureSubscriptionForStorageAndWebAppSlot }}
            scriptLocation: inlineScript
            scriptType: ps
            inlineScript: deployment/create-container.ps1 -StorageAccountName $(storageAccountName)
            workingDirectory: $(Build.SourcesDirectory)

        - task: AzureFileCopy@6
          displayName: ðŸŸ£Upload index to Azure Storage
          inputs:
            azureSubscription: ${{ variables.azureSubscriptionForStorageAndWebAppSlot }}
            SourcePath: "bin/index/index/*"
            Destination: AzureBlob
            storage: $(storageAccountName)
            ContainerName: $(NEW_CONTAINER_NAME)

        - task: AzureRmWebAppDeployment@4
          displayName: 'ðŸŸ£Azure App Service Deploy: $(temporaryDeploymentSlot) slot'
          inputs:
            ConnectionType: AzureRM
            azureSubscription: ${{ variables.azureSubscriptionForStorageAndWebAppSlot }}
            appType: webApp
            WebAppName: ${{ variables.webAppName }}
            ResourceGroupName: $(resourceGroupName)
            deployToSlotOrASE: true
            SlotName: $(temporaryDeploymentSlot)
            packageForLinux: bin/webapp-stage/
            enableCustomDeployment: true
            DeploymentType: zipDeploy
            RemoveAdditionalFilesFlag: true

        - task: AzureCLI@2
          displayName: ðŸŸ£Deploy Storage Proxy Url to WebApp
          inputs:
            azureSubscription: ${{ variables.azureSubscriptionForStorageAndWebAppSlot }}
            scriptLocation: inlineScript
            scriptType: ps
            inlineScript: >
              deployment/deploy-storage-proxy.ps1
              -NewContainerName "$(NEW_CONTAINER_NAME)"
              -ResourceGroup "$(resourceGroupName)"
              -StorageAccountName "$(storageAccountName)"
              -WebappName "${{ variables.webAppName }}"
              -Slot "$(temporaryDeploymentSlot)"

        - task: AzureCLI@2
          displayName: ðŸŸ£Restart WebApp
          inputs:
            azureSubscription: ${{ variables.azureSubscriptionForStorageAndWebAppSlot }}
            scriptLocation: inlineScript
            scriptType: ps
            inlineScript: |
              az webapp restart --name $(webAppName) --slot $(temporaryDeploymentSlot) --resource-group $(resourceGroupName)

        # FIXME: Health endpoints disabled till they can be audited: "https://$(stagingHost)/health", "https://$(stagingHost)/health/alive"
        - pwsh: |
            Start-Sleep 60
            $urls = @(
              "https://$(stagingHost)"
              "https://$(stagingHost)/System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/String.cs.html"
            )
            foreach ($url in $urls) {
              Write-Host "Testing URL: $url"
              try {
                $statusCode = Invoke-WebRequest $url -UseBasicParsing -SkipHttpErrorCheck | select -ExpandProperty StatusCode
                if ($statusCode -ne 200) {
                  Write-Error "##vso[task.logissue type=warning;]Deployed staging website returned unexpected status code $statusCode from url $url"
                }
              } catch {
                Write-Error "##vso[task.logissue type=warning;]Failed to test URL $url : $_"
              }
            }
          displayName: ðŸŸ£Test Deployed WebApp
          condition: and(succeeded(), eq(variables['isOfficialBuild'], 'True'))

        - task: AzureCLI@2
          displayName: ðŸŸ£Swap Staging Slot into Production
          condition: and(succeeded(), eq(variables['isOfficialBuild'], 'True'))
          inputs:
            azureSubscription: ${{ variables.azureSubscriptionForStorageAndWebAppSlot }}
            scriptLocation: inlineScript
            scriptType: ps
            inlineScript: >
              az webapp deployment slot swap
              --resource-group $(resourceGroupName)
              --name $(webAppName)
              --slot $(temporaryDeploymentSlot)
              --target-slot production

        - task: AzureCLI@2
          displayName: ðŸŸ£Cleanup Old Storage Containers
          condition: and(succeeded(), eq(variables['isOfficialBuild'], 'True'))
          inputs:
            azureSubscription: ${{ variables.azureSubscriptionForStorageAndWebAppSlot }}
            scriptLocation: inlineScript
            scriptType: ps
            inlineScript: >
              deployment/cleanup-old-containers.ps1
              -ResourceGroup $(resourceGroupName)
              -WebappName $(webAppName)
              -StorageAccountName $(storageAccountName)

        - task: CopyFiles@2
          displayName: Copy binlogs for upload
          inputs:
            SourceFolder: '$(Build.SourcesDirectory)'
            Contents: |
              **/*.binlog
            TargetFolder: $(Build.ArtifactStagingDirectory)/logs/src
            CleanTargetFolder: false
          continueOnError: true
          condition: succeededOrFailed()
